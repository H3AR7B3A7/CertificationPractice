# 1Z0-816 & 1ZO-817

## Chapter 1: Java Fundamentals

### Final Modifier

- Local variables: 
  - Can only be assigned once
  - Must be initialized before it can be used
- Instance variables: 
  - Can only be assigned once inline, in initialization block or constructor
  - Must be initialized
- Class variables: 
  - Can only be assigned once inline or in static initialization block
  - Must be initialized
- Methods:
  - Can't be overridden
- Classes:
  - Can't be inherited
    
### Enum

- List of static enumerated members
- All values are each constructed, the first time any enum value gets called
- Can also have:
  - Instance variables (good practice: final)
  - Constructor (implicitly private)
  - Methods

### Nested Class

- Inner class
- Static nested class
- Local class
- Anonymous class

**Inner Class**:
- Can have any access modifier
- Can extend any class or implement interfaces
- Can not declare static fields or members except for static finals
- Can access members of the outer class including private ones
- Require an instance of the outer class to be constructed

**Static Nested Class**:
- Can have any access modifier
- Can be instantiated without an instance of the outer class
- Can't access instance variables or methods without a reference to an outer class instance
- The outer class can refer to methods and fields in the static nested class
- Creates a namespace
- Can be imported with a regular import

**Local Class**:
- Does not have access modifier
- Defined within a method and only exists when that method is called
- Can not declare static fields or members except for static finals
- They have access to all fields and methods of the enclosing class
- They can access local variables that are effectively final

**Anonymous Inner Class**:
- Is a sort of local class, without a name:
  - Does not have access modifier
  - Defined within a method and only exists when that method is called
  - Can not declare static fields or members except for static finals
  - They have access to all fields and methods of the enclosing class
  - They can access local variables that are effectively final
- Can't be abstract or final
- Can't both extend and/or have multiple interfaces
- Is created with an abstract class or interface as model
- Is a concise way of creating a class we use only once
- Was used more often before lambda expressions (with functional interfaces)

### Interface

**Members**:
- Constant variable
- Abstract method
- Default method
- Static method
- Private method
- Private static method

**Default Interface Method**:
- Can only be declared within an interface
- Must include a method body (default implementation)
- Assumed to be public
- Can't be abstract, final or static
- Can be overridden
- Must be overridden if another default method with the same name is inherited

**Static Interface Method**:
- Assumed to be public
- Can't be marked abstract or final
- Is not inherited

**Private Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can only be called by default and other private methods

**Private Static Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can also be used in static methods

### Functional Programming

Functional interfaces are used as the basis for lambda expressions in functional programming.
A functional interface is an interface with a single abstract method.

**Functional Interface**:
- Can hold one abstract method
- Can override any amount of abstract methods from object
- Can hold any amount of other non-abstract methods

Predefined functional interfaces:
- Predicate
- ... (more in chapter 3 & 4)

**Lambda**:
- Infers the types from the surrounding context
- Can use variables from 3 places:
  - The parameters
  - Local variables created in the lambda body
  - Variables outside the lambda referenced from the body
- When var is used in params, all params need to be var
- Variables referenced from the lambda body need to be effectively final

## Chapter 2: Annotations

Annotations allow us to add metadata to our code. 
Before annotations this metadata often had to be provided by XML or JSON.

Advantages:
- Metadata in the class
- Fewer files in the project

**Annotation**:
- Is public or package-private (default)
- Is created with an annotation
- Without any elements is called a marker annotation
- Elements without default values are considered required
- A default value must be a non-null constant expression
- Elements can be declared with a(n):
  - Primitive
  - String
  - Class
  - Enum
  - Annotation
  - Array of the above
- Elements are implicitly abstract and public
- Elements can't be marked final
- Variables are implicitly public static final
- They can be applied to:
  - Classes, interfaces, enums and modules
  - Variables (static, instance and local)
  - Methods and constructors
  - Parameters (method, constructor, lambda)
  - Cast expressions
  - Other annotations

**Value**:

The element name for 'value' can be omitted:
- Value can be optional or required
- There can be no other elements required
- The annotation can not provide values for other annotations

*If other optionals are defines in the annotation the element name for value is required.*

### Annotation-Specific Annotations

#### @Target

We can specify a declaration type with @Target and limit the types our custom annotation can be used for.

ElementType values:
- TYPE
- FIELD
- METHOD
- PARAMETER
- CONSTRUCTOR
- LOCAL_VARIABLE
- ANNOTATION_TYPE
- PACKAGE
- TYPE_PARAMETER
- TYPE_USE
- MODULE

#### @Retention

We can specify the behaviour of the compiler when it comes to retaining annotation information with @Retention.

RetentionPolicy values:
- SOURCE
- CLASS
- RUNTIME (*Uses reflection)

#### @Documented

Will make the annotation to which it is applied documented in the Javadocs.

#### @Inherited

Will make the annotation be inherited by subclasses.

#### @Repeatable

Will make the annotation usable more than once on a type.

*This annotation needs another annotation passed to the value element, 
which takes an array of the annotation you are creating as its value.*

### Javadoc Annotations

Javadoc has its own annotations that are not capitalized. They are used mainly for Javadoc styling.

### Built-In Annotations

#### @Override

Override is a marker annotation used to indicate a method is overriding an inherited method.
It will not compile if the method is not actually being overridden.

#### @FunctionalInterface

FunctionalInterface is a marker annotation used to indicate functional interfaces.
It will not compile if the interface is not actually fit the Single Abstract Method rule.

#### @Deprecated

Deprecated is a marker annotation used to indicate a method that will be removed from the API.
Not to be confused with the *@deprecated* from Javadocs.

#### @SuppressWarnings

SuppressWarnings is a marker annotation used to suppress warnings from the compiler.

Values:
- Deprecation
- Unchecked

#### @SafeVarargs

SafeVarargs is a marker annotation used to suppress warnings about unsafe operations using varargs.
It can only be used on methods or constructors using varargs that are either private, static or final.

## Chapter 3: Generics and Collections

**Functional Interfaces**:
- Supplier
- Consumer
- BiConsumer
- Predicate
- BiPredicate
- Function
- BiFunction
- UnaryOperator

**Method reference**:
Method references are used to refer to a method of a functional interface. They are even more compact than a lambda expression.
Each time when you are using a lambda expression referring to a method, you can replace your lambda expression with a method reference.
They prevent the redundant repeat of the parameter.

Four formats:
- Static methods
- Instance methods on an instance
- Instance methods on a parameter
- Constructors




