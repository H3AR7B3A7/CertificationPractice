# 1Z0-816 & 1ZO-817

## Chapter 1: Java Fundamentals

### Final Modifier

- Local variables: 
  - Can only be assigned once
  - Must be initialized before it can be used
- Instance variables: 
  - Can only be assigned once inline, in initialization block or constructor
  - Must be initialized
- Class variables: 
  - Can only be assigned once inline or in static initialization block
  - Must be initialized
- Methods:
  - Can't be overridden
- Classes:
  - Can't be inherited
    
### Enum

- List of static enumerated members
- All values are each constructed, the first time any enum value gets called
- Can also have:
  - Instance variables (good practice: final)
  - Constructor (implicitly private)
  - Methods

### Nested Class

- Inner class
- Static nested class
- Local class
- Anonymous class

**Inner Class**:
- Can have any access modifier
- Can extend any class or implement interfaces
- Can not declare static fields or members except for static finals
- Can access members of the outer class including private ones
- Require an instance of the outer class to be constructed

**Static Nested Class**:
- Can have any access modifier
- Can be instantiated without an instance of the outer class
- Can't access instance variables or methods without a reference to an outer class instance
- The outer class can refer to methods and fields in the static nested class
- Creates a namespace
- Can be imported with a regular import

**Local Class**:
- Does not have access modifier
- Defined within a method and only exists when that method is called
- Can not declare static fields or members except for static finals
- They have access to all fields and methods of the enclosing class
- They can access local variables that are effectively final

**Anonymous Inner Class**:
- Is a sort of local class, without a name:
  - Does not have access modifier
  - Defined within a method and only exists when that method is called
  - Can not declare static fields or members except for static finals
  - They have access to all fields and methods of the enclosing class
  - They can access local variables that are effectively final
- Can't be abstract or final
- Can't both extend and/or have multiple interfaces
- Is created with an abstract class or interface as model
- Is a concise way of creating a class we use only once
- Was used more often before lambda expressions (with functional interfaces)

### Interface

**Members**:
- Constant variable
- Abstract method
- Default method
- Static method
- Private method
- Private static method

**Default Interface Method**:
- Can only be declared within an interface
- Must include a method body (default implementation)
- Assumed to be public
- Can't be abstract, final or static
- Can be overridden
- Must be overridden if another default method with the same name is inherited

**Static Interface Method**:
- Assumed to be public
- Can't be marked abstract or final
- Is not inherited

**Private Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can only be called by default and other private methods

**Private Static Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can also be used in static methods

### Functional Programming

Functional interfaces are used as the basis for lambda expressions in functional programming.
A functional interface is an interface with a single abstract method.

**Functional Interface**:
- Can hold one abstract method
- Can override any amount of abstract methods from object
- Can hold any amount of other non-abstract methods

Predefined functional interfaces:
- Predicate
- ... (more in chapter 3 & 4)

**Lambda**:
- Infers the types from the surrounding context
- Can use variables from 3 places:
  - The parameters
  - Local variables created in the lambda body
  - Variables outside the lambda referenced from the body
- When var is used in params, all params need to be var
- Variables referenced from the lambda body need to be effectively final

## Chapter 2: Annotations

Annotations allow us to add metadata to our code. 
Before annotations this metadata often had to be provided by XML or JSON.

Advantages:
- Metadata in the class
- Fewer files in the project

**Annotation**:
- Is public or package-private (default)
- Is created with an annotation
- Without any elements is called a marker annotation
- Elements without default values are considered required
- A default value must be a non-null constant expression
- Elements can be declared with a(n):
  - Primitive
  - String
  - Class
  - Enum
  - Annotation
  - Array of the above
- Elements are implicitly abstract and public
- Elements can't be marked final
- Variables are implicitly public static final
- They can be applied to:
  - Classes, interfaces, enums and modules
  - Variables (static, instance and local)
  - Methods and constructors
  - Parameters (method, constructor, lambda)
  - Cast expressions
  - Other annotations

**Value**:

The element name for 'value' can be omitted:
- Value can be optional or required
- There can be no other elements required
- The annotation can not provide values for other annotations

*If other optionals are defines in the annotation the element name for value is required.*

### Annotation-Specific Annotations

#### @Target

We can specify a declaration type with @Target and limit the types our custom annotation can be used for.

ElementType values:
- TYPE
- FIELD
- METHOD
- PARAMETER
- CONSTRUCTOR
- LOCAL_VARIABLE
- ANNOTATION_TYPE
- PACKAGE
- TYPE_PARAMETER
- TYPE_USE
- MODULE

#### @Retention

We can specify the behaviour of the compiler when it comes to retaining annotation information with @Retention.

RetentionPolicy values:
- SOURCE
- CLASS
- RUNTIME (*Uses reflection)

#### @Documented

Will make the annotation to which it is applied documented in the Javadocs.

#### @Inherited

Will make the annotation be inherited by subclasses.

#### @Repeatable

Will make the annotation usable more than once on a type.

*This annotation needs another annotation passed to the value element, 
which takes an array of the annotation you are creating as its value.*

### Javadoc Annotations

Javadoc has its own annotations that are not capitalized. They are used mainly for Javadoc styling.

### Built-In Annotations

#### @Override

Override is a marker annotation used to indicate a method is overriding an inherited method.
It will not compile if the method is not actually being overridden.

#### @FunctionalInterface

FunctionalInterface is a marker annotation used to indicate functional interfaces.
It will not compile if the interface is not actually fit the Single Abstract Method rule.

#### @Deprecated

Deprecated is a marker annotation used to indicate a method that will be removed from the API.
Not to be confused with the *@deprecated* from Javadocs.

#### @SuppressWarnings

SuppressWarnings is a marker annotation used to suppress warnings from the compiler.

Values:
- Deprecation
- Unchecked

#### @SafeVarargs

SafeVarargs is a marker annotation used to suppress warnings about unsafe operations using varargs.
It can only be used on methods or constructors using varargs that are either private, static or final.

## Chapter 3: Generics and Collections

**Functional Interfaces**:
- Supplier
- Consumer
- BiConsumer
- Predicate
- BiPredicate
- Function
- BiFunction
- UnaryOperator

**Method reference**:
Method references are used to refer to a method of a functional interface. They are even more compact than a lambda expression.
Each time when you are using a lambda expression referring to a method, you can replace your lambda expression with a method reference.
They prevent the redundant repeat of the parameter.

Four formats:
- Static methods
- Instance methods on an instance
- Instance methods on a parameter
- Constructors

### Collections

**Collection Interfaces**:
- List
  - Ordered
  - Allows duplicate
- Set
  - Not ordered
  - Does not allow duplicate
- Queue
  - Specific order (fifo, priority, reversed priority, ...)
  - Allows duplicate
- Map
  - Key- / value pairs
  - Does not allow duplicate keys

*The behavior of these interfaces can change depending on the underlying implementation.*

**Collection Methods**:
- *add()*
>boolean add(E element)
- *remove()*
>boolean remove(Object o)
- *isEmpty()* and *size()*
>boolean isEmpty()  
>int size()
- *clear()*
>void clear()
- *contains()*
>boolean contains(Object o)
- *removeIf()*
>boolean removeIf(Predicate<? super E> filter)
- *forEach()*
>void forEach(Consumer<? super T> action)

### List

**Creating a list with factory methods:**
- *Arrays.asList(varargs)*:
  - Returns fixed size list backed by an array
  - Can replace element
  - Can't add or delete elements
  - Values in array effect list and vice versa
  
- *List.of(varargs)*:
  - Returns immutable list
  - Can't replace, add or remove elements
  
- *List.copyOf(collection)*:
  - Returns immutable list
  - Can't replace, add or remove elements

**List Methods**:  
*The list interface adds some more specific methods and overloads to the ones in Collection.*
- *add()*
>void add(int index, E element)
- *get()*
>E get(int index)
- *remove()*
>E remove(int index)
- *replaceAll()*
>void replaceAll(UnaryOperator<E> op)
- *set()*
>E set(int index, E e)

**Implementations of List**:
- ArrayList: Fast lookup, slower to add and remove
- LinkedList: Fast to lookup, add and remove at start or end
- Vector: concurrency

### Set

**Creating a set with factory methods**:
- *Set.of(varargs)*
  - Returns immutable set
  - Can't replace, add or remove elements
- *Set.copyOf(collection)*
  - Returns immutable set
  - Can't replace, add or remove elements

**Implementations of Set**:
- HashSet: Fast
- TreeSet: Sorted but slower / Null not allowed / Requires the object to implement comparable or a comparator as a parameter
- LinkedHashSet

### Queue

**Queue Methods**:  
*The queue interface adds some more specific methods and overloads to the ones in Collection.
Also, add() and some others functions\* throw an exception on failure.*
- *element()**
>E element()
- *offer()*
>boolean offer(E element)
- *remove()**
>E remove()
- *poll()*
>E poll()
- *peek()*
>E peek()

**Implementations of Queue**:
- LinkedList: Can insert at front and back (Fifo, Lifo)
- PriorityQueue: Ordered
- ArrayDeque: Fast
- Stack: concurrency

### Map

**Creating a map with factory methods**:
- *Map.of(key, value, key, value, ...)*
  - Number of parameters must be even (or in pairs)
  - Can't take an array like List.of and Set.of()
  - Returns immutable map
  - Can't replace, add or remove elements
- *Map.copyOf(map)*
  - Can't take just any collection like List.copyOf and Set.copyOf()
  - Returns immutable map
  - Can't replace, add or remove elements
  
**Map Methods**:  
*The map interface adds some more specific methods and overloads to the ones in Collection.*
- *containsKey()*
>boolean containsKey(Object key)
- *containsValue()*
>boolean containsValue(Object value)
- *entrySet()*
>Set<Map.entry<K, V>> entrySet()
- *forEach()*
>void forEach(BiConsumer<? super K, ? super V> action)
- *get()*
>V get(Object key)
- *getOrDefault()*
>V getOrDefault(Object key, V default)
- *keySet()*
>Set<K> keySet()
- *merge()*
>V merge(K key, V value, Function<? super V, ? super V, ? extends V> remappingFunction)
- *put()*
>V put(K key, V value)
- *putIfAbsent()*
>V putIfAbsent(K key, V value)
- *remove()*
>V remove(Object key)
- *replace()*
>V replace(K key, V value)
- *replaceAll()*
>void replaceAll(BiFunction<? super K, ? super V, ? extends V> function))
- *values()*
>Collection<V> values()

**Implementations of Map**:
- HashMap: Fast
- TreeMap: Ordered by keys / Null not allowed / Requires the object to implement comparable or a comparator as a parameter
- LinkedHashMap
- HashTable: concurrency

### Sorting

#### Comparable  

*An interface we should implement on our objects when we want to specify the way they should be sorted.*
- Package java.lang
- One parameter


    public interface Comparable<T> {
      int CompareTo(T o);
    }

When implementing comparable:
- Check for null
- Keep compareTo() and equals() consistent

#### Comparator  

*We don't always have or need a comparable interface. Sometimes we want different sorting methods.
This is where the Comparator shines.*
- Package java.util
- Two parameters


    public interface Comparator<T> {
      int compare(T o1, T o2);
    }

Example lambda:
>(o1, o2) -> o1.getField() - o2.getField()

*In theory both Comparable and Comparator are functional interfaces, but only Comparator should be used as such.
The comparator can be defined with a lambda or method reference. However, comparable should be implemented to the class it compares.*

**Comparator Methods**:
- *comparing(function)*
- *comparingDouble(function)*
- *comparingInt(function)*
- *comparingLong(function)*
- *naturalOrder()*
- *reverseOrder()*

**Chainable methods**:
- *reversed()*
- *thenComparing(function)*
- *thenComparingDouble(function)*
- *thenComparingInt(function)*
- *thenComparingLong(function)*

### Generics

*Generics are use where we don't want to be type specific and are creating functionality that do not need to have 
a connection to the types they work with. Collections make a lot of use of generics.*

**Naming convention**:
- E for an element
- K for a map key
- V for a map value
- N for a number
- T for a generic data type
- S, U, V, ... for multiple generic types

**Type Erasure**:  
*Type erasure can be explained as the process of enforcing type constraints only at compile time and discarding 
the element type information at runtime.*

For example:

    class Crate<T> {
      private T content;
  
      public void loadCrate(T content){
          this.content = content;
      }
  
      public T unloadCrate(){
          return content;
      }
    }

Will be compiled to:

    class Crate {
      private Object content;
  
      public void loadCrate(Object content){
          this.content = content;
      }
  
      public Object unloadCrate(){
          return content;
      }
    }

#### Generic Interfaces

Interfaces can use generic types too:

    public interface Shippable<T> {
      void ship(T t);
    }

*When implemented to a class we can choose to specify a type or a generic type.
We can also just use Object instead of generics.*

#### Generic Methods

We can also use them in methods:

    public static <T> Crate<T> ship(T t){
        return new Crate<>();
    }

*We declare the formal type parameter before the return type.*

We can call this method normally, or define the type:

    Crate.ship("package")
    Crate.<String>ship("package")

#### What we can't do with generics

- Call a constructor (new T)
- Create an array of a generic type
- Call instanceof
- Use a primitive type as a generic type
- Create a static variable as a generic type

#### Bounding Generic Types

Wildcards:
- Unbounded wildcard
  - ?
  - Any type
- Upper-bounded wildcard
  - ? extends type
  - This type or any subtype
- Lower-bounded wildcard
  - ? super type
  - This type or any supertype

## Chapter 4: Functional Programming

**Functional Interfaces**:
- Supplier
```
public interface Supplier<T> {
  T get();
}
```
- Consumer
```
public interface Consumer<T> {
  void accept(T t);
}
```
- BiConsumer
```
public interface Biconsumer<T, U> {
  void accept(T t, U u);
}
```
- Predicate
```
public interface Predicate<T> {
  test(T t);
}
```
- BiPredicate
```
public interface BiPredicate<T, U> {
  test(T t, U u);
}
```
- Function
```
public interface Function<T, R> {
  R apply(T t);
}
```
- BiFunction
```
public interface BiFUnction<T, U, R> {
  R apply(T t, U u);
}
```
- UnaryOperator
```
public interface UnaryOperator<T> extends Function<T, T> {
  T apply(T t);
}
```
- BinaryOperator
```
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
  T apply(T t1, T t2);
}
```

**Convenience Methods**:
- Consumer
  - *andThen()*
- Function
  - *andThen()*
  - *compose()*
- Predicate
  - *and()*
  - *negate()*
  - *or()*

### Optional

The purpose of an optional is to provide a type-level solution for representing optional values instead of null references.

**Advantages over null**:
- Statement by API there might not be a value
- Functional programming
- Chaining optional calls

**Factory Methods**:
- *Optional.empty()*
- *Optional.of()*
- *Optional.ofNullable()*

**Methods**:
- *isPresent()*
- *get()*
- *ifPresent(Consumer c)*
- *orElse(T other)*
- *orElseGet(Supplier s)*
- *orElseThrow()*
- *orElseThrow(Supplier s)*

### Streams

Streams are like an assembly line, where Java is the foreman putting operators to work.
Every previous operation has to complete before the next can start.

Pipeline flow:
- Source
- Intermediate operations
- Terminal operation

#### Stream Sources

**Factory Methods**:
- Finite
  - *Stream.empty()*
  - *Stream.of()*
- Infinite
  - *Stream.generate()*
  - *Stream.iterate()*

**Collection API**:
- *stream()*
- *parallelStream()*

#### Terminal Operations

- *count()*
- *min()*
- *max()*
- *findAny()*
- *findFirst()*
- *allMatch()*
- *anyMatch()*
- *noneMatch()*
- *forEach()*
- *reduce()*
- *collect()*

#### Intermediate Operations

- *filter()*
- *distinct()*
- *limit()*
- *skip()*
- *map()*
- *flatMap()*
- *sorted()*
- *peek()*

### Primitive Streams

**Types**:
- IntStream
- LongStream
- DoubleStream

**Factory Methods**:
- Finite
  - *Stream.empty()*
  - *Stream.of()*
- Infinite
  - *Stream.generate()*
  - *Stream.iterate()*
  
**Primitive Stream Methods**:
- *average()*
>OptionalDouble average()
- *boxed()*
>Stream<T> boxed()
- *max()*
>OptionalInt max()
- *min()*
>OptionalLong min()
- *range(long a, long b)*
>IntStream range()
- *rangeClosed()*
>IntStream rangeClosed(int a, int b)
- *sum()*
> int sum()
- *summaryStatistics()*
> IntSummaryStatistics summaryStatistics()

#### Optionals with Primitive Streams

**Types**:
- OptionalInt
- OptionalDouble
- OptionalLong


#### Summary Statistics

We can only use one terminal operation on a stream once. If we want to do more calculations like getting an average, min and max and more,
we can use the summary statistics methods with our primitive streams.

- IntSummaryStatistics
- LongSummaryStatistics
- DoubleSummaryStatistics

Method:
- *summaryStatistics()*

#### Functional Interfaces for Primitives

Boolean~:
- BooleanSupplier

Int- Long- and Double~:
- IntSupplier
- IntConsumer
- IntPredicate
- IntFunction<R>
- IntUnaryOperator
- IntBinaryOperator


- ToIntFunction
- ToIntBiFunction
- IntToLongFunction
- IntToDoubleFunction
- ObjIntConsumer

*All of these also have their Double and Long variations.*



