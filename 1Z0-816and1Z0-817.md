# 1Z0-816 & 1ZO-817

## Chapter 1: Java Fundamentals

### Final Modifier

- Local variables: 
  - Can only be assigned once
  - Must be initialized before it can be used
- Instance variables: 
  - Can only be assigned once inline, in initialization block or constructor
  - Must be initialized
- Class variables: 
  - Can only be assigned once inline or in static initialization block
  - Must be initialized
- Methods:
  - Can't be overridden
- Classes:
  - Can't be inherited
    
### Enum

- List of static enumerated members
- All values are each constructed, the first time any enum value gets called
- Can also have:
  - Instance variables (good practice: final)
  - Constructor (implicitly private)
  - Methods

### Nested Class

- Inner class
- Static nested class
- Local class
- Anonymous class

**Inner Class**:
- Can have any access modifier
- Can extend any class or implement interfaces
- Can not declare static fields or members except for static finals
- Can access members of the outer class including private ones
- Require an instance of the outer class to be constructed

**Static Nested Class**:
- Can have any access modifier
- Can be instantiated without an instance of the outer class
- Can't access instance variables or methods without a reference to an outer class instance
- The outer class can refer to methods and fields in the static nested class
- Creates a namespace
- Can be imported with a regular import

**Local Class**:
- Does not have access modifier
- Defined within a method and only exists when that method is called
- Can not declare static fields or members except for static finals
- They have access to all fields and methods of the enclosing class
- They can access local variables that are effectively final

**Anonymous Inner Class**:
- Is a sort of local class, without a name:
  - Does not have access modifier
  - Defined within a method and only exists when that method is called
  - Can not declare static fields or members except for static finals
  - They have access to all fields and methods of the enclosing class
  - They can access local variables that are effectively final
- Can't be abstract or final
- Can't both extend and/or have multiple interfaces
- Is created with an abstract class or interface as model
- Is a concise way of creating a class we use only once
- Was used more often before lambda expressions (with functional interfaces)

### Interface

**Members**:
- Constant variable
- Abstract method
- Default method
- Static method
- Private method
- Private static method

**Default Interface Method**:
- Can only be declared within an interface
- Must include a method body (default implementation)
- Assumed to be public
- Can't be abstract, final or static
- Can be overridden
- Must be overridden if another default method with the same name is inherited

**Static Interface Method**:
- Assumed to be public
- Can't be marked abstract or final
- Is not inherited

**Private Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can only be called by default and other private methods

**Private Static Interface Methods**:
- Can't be used outside the interface
- Mostly to prevent code duplication
- Can also be used in static methods

### Functional Programming

Functional interfaces are used as the basis for lambda expressions in functional programming.
A functional interface is an interface with a single abstract method.

**Functional Interface**:
- Can hold one abstract method
- Can override any amount of abstract methods from object
- Can hold any amount of other non-abstract methods

Predefined functional interfaces:
- Predicate
- ... (more in chapter 3 & 4)

**Lambda**:
- Infers the types from the surrounding context
- Can use variables from 3 places:
  - The parameters
  - Local variables created in the lambda body
  - Variables outside the lambda referenced from the body
- When var is used in params, all params need to be var
- Variables referenced from the lambda body need to be effectively final

## Chapter 2: Annotations

Annotations allow us to add metadata to our code. 
Before annotations this metadata often had to be provided by XML or JSON.

Advantages:
- Metadata in the class
- Fewer files in the project

**Annotation**:
- Is public or package-private (default)
- Is created with an annotation
- Without any elements is called a marker annotation
- Elements without default values are considered required
- A default value must be a non-null constant expression
- Elements can be declared with a(n):
  - Primitive
  - String
  - Class
  - Enum
  - Annotation
  - Array of the above
- Elements are implicitly abstract and public
- Elements can't be marked final
- Variables are implicitly public static final
- They can be applied to:
  - Classes, interfaces, enums and modules
  - Variables (static, instance and local)
  - Methods and constructors
  - Parameters (method, constructor, lambda)
  - Cast expressions
  - Other annotations

**Value**:

The element name for 'value' can be omitted:
- Value can be optional or required
- There can be no other elements required
- The annotation can not provide values for other annotations

*If other optionals are defines in the annotation the element name for value is required.*

### Annotation-Specific Annotations

#### @Target

We can specify a declaration type with @Target and limit the types our custom annotation can be used for.

ElementType values:
- TYPE
- FIELD
- METHOD
- PARAMETER
- CONSTRUCTOR
- LOCAL_VARIABLE
- ANNOTATION_TYPE
- PACKAGE
- TYPE_PARAMETER
- TYPE_USE
- MODULE

#### @Retention

We can specify the behaviour of the compiler when it comes to retaining annotation information with @Retention.

RetentionPolicy values:
- SOURCE
- CLASS
- RUNTIME (*Uses reflection)

#### @Documented

Will make the annotation to which it is applied documented in the Javadocs.

#### @Inherited

Will make the annotation be inherited by subclasses.

#### @Repeatable

Will make the annotation usable more than once on a type.

*This annotation needs another annotation passed to the value element, 
which takes an array of the annotation you are creating as its value.*

### Javadoc Annotations

Javadoc has its own annotations that are not capitalized. They are used mainly for Javadoc styling.

### Built-In Annotations

#### @Override

Override is a marker annotation used to indicate a method is overriding an inherited method.
It will not compile if the method is not actually being overridden.

#### @FunctionalInterface

FunctionalInterface is a marker annotation used to indicate functional interfaces.
It will not compile if the interface is not actually fit the Single Abstract Method rule.

#### @Deprecated

Deprecated is a marker annotation used to indicate a method that will be removed from the API.
Not to be confused with the *@deprecated* from Javadocs.

#### @SuppressWarnings

SuppressWarnings is a marker annotation used to suppress warnings from the compiler.

Values:
- Deprecation
- Unchecked

#### @SafeVarargs

SafeVarargs is a marker annotation used to suppress warnings about unsafe operations using varargs.
It can only be used on methods or constructors using varargs that are either private, static or final.

## Chapter 3: Generics and Collections

**Functional Interfaces**:
- Supplier
- Consumer
- BiConsumer
- Predicate
- BiPredicate
- Function
- BiFunction
- UnaryOperator

**Method reference**:
Method references are used to refer to a method of a functional interface. They are even more compact than a lambda expression.
Each time when you are using a lambda expression referring to a method, you can replace your lambda expression with a method reference.
They prevent the redundant repeat of the parameter.

Four formats:
- Static methods
- Instance methods on an instance
- Instance methods on a parameter
- Constructors

### Collections

**Collection Interfaces**:
- List
  - Ordered
  - Allows duplicate
- Set
  - Not ordered
  - Does not allow duplicate
- Queue
  - Specific order (fifo, priority, reversed priority, ...)
  - Allows duplicate
- Map
  - Key- / value pairs
  - Does not allow duplicate keys

*The behavior of these interfaces can change depending on the underlying implementation.*

**Collection Methods**:
- *add()*
>boolean add(E element)
- *remove()*
>boolean remove(Object o)
- *isEmpty()* and *size()*
>boolean isEmpty()  
>int size()
- *clear()*
>void clear()
- *contains()*
>boolean contains(Object o)
- *removeIf()*
>boolean removeIf(Predicate<? super E> filter)
- *forEach()*
>void forEach(Consumer<? super T> action)

### List

**Creating a list with factory methods:**
- *Arrays.asList(varargs)*:
  - Returns fixed size list backed by an array
  - Can replace element
  - Can't add or delete elements
  - Values in array effect list and vice versa
  
- *List.of(varargs)*:
  - Returns immutable list
  - Can't replace, add or remove elements
  
- *List.copyOf(collection)*:
  - Returns immutable list
  - Can't replace, add or remove elements

**List Methods**:  
*The list interface adds some more specific methods and overloads to the ones in Collection.*
- *add()*
>void add(int index, E element)
- *get()*
>E get(int index)
- *remove()*
>E remove(int index)
- *replaceAll()*
>void replaceAll(UnaryOperator<E> op)
- *set()*
>E set(int index, E e)

**Implementations of List**:
- ArrayList: Fast lookup, slower to add and remove
- LinkedList: Fast to lookup, add and remove at start or end
- Vector: concurrency

### Set

**Creating a set with factory methods**:
- *Set.of(varargs)*
  - Returns immutable set
  - Can't replace, add or remove elements
- *Set.copyOf(collection)*
  - Returns immutable set
  - Can't replace, add or remove elements

**Implementations of Set**:
- HashSet: Fast
- TreeSet: Sorted but slower / Null not allowed / Requires the object to implement comparable or a comparator as a parameter
- LinkedHashSet

### Queue

**Queue Methods**:  
*The queue interface adds some more specific methods and overloads to the ones in Collection.
Also, add() and some others functions\* throw an exception on failure.*
- *element()**
>E element()
- *offer()*
>boolean offer(E element)
- *remove()**
>E remove()
- *poll()*
>E poll()
- *peek()*
>E peek()

**Implementations of Queue**:
- LinkedList: Can insert at front and back (Fifo, Lifo)
- PriorityQueue: Ordered
- ArrayDeque: Fast
- Stack: concurrency

### Map

**Creating a map with factory methods**:
- *Map.of(key, value, key, value, ...)*
  - Number of parameters must be even (or in pairs)
  - Can't take an array like List.of and Set.of()
  - Returns immutable map
  - Can't replace, add or remove elements
- *Map.copyOf(map)*
  - Can't take just any collection like List.copyOf and Set.copyOf()
  - Returns immutable map
  - Can't replace, add or remove elements
  
**Map Methods**:  
*The map interface adds some more specific methods and overloads to the ones in Collection.*
- *containsKey()*
>boolean containsKey(Object key)
- *containsValue()*
>boolean containsValue(Object value)
- *entrySet()*
>Set<Map.entry<K, V>> entrySet()
- *forEach()*
>void forEach(BiConsumer<? super K, ? super V> action)
- *get()*
>V get(Object key)
- *getOrDefault()*
>V getOrDefault(Object key, V default)
- *keySet()*
>Set<K> keySet()
- *merge()*
>V merge(K key, V value, Function<? super V, ? super V, ? extends V> remappingFunction)
- *put()*
>V put(K key, V value)
- *putIfAbsent()*
>V putIfAbsent(K key, V value)
- *remove()*
>V remove(Object key)
- *replace()*
>V replace(K key, V value)
- *replaceAll()*
>void replaceAll(BiFunction<? super K, ? super V, ? extends V> function))
- *values()*
>Collection<V> values()

**Implementations of Map**:
- HashMap: Fast
- TreeMap: Ordered by keys / Null not allowed / Requires the object to implement comparable or a comparator as a parameter
- LinkedHashMap
- HashTable: concurrency

### Sorting

#### Comparable  

*An interface we should implement on our objects when we want to specify the way they should be sorted.*
- Package java.lang
- One parameter


    public interface Comparable<T> {
      int CompareTo(T o);
    }

When implementing comparable:
- Check for null
- Keep compareTo() and equals() consistent

#### Comparator  

*We don't always have or need a comparable interface. Sometimes we want different sorting methods.
This is where the Comparator shines.*
- Package java.util
- Two parameters


    public interface Comparator<T> {
      int compare(T o1, T o2);
    }

Example lambda:
>(o1, o2) -> o1.getField() - o2.getField()

*In theory both Comparable and Comparator are functional interfaces, but only Comparator should be used as such.
The comparator can be defined with a lambda or method reference. However, comparable should be implemented to the class it compares.*

**Comparator Methods**:
- *comparing(function)*
- *comparingDouble(function)*
- *comparingInt(function)*
- *comparingLong(function)*
- *naturalOrder()*
- *reverseOrder()*

**Chainable methods**:
- *reversed()*
- *thenComparing(function)*
- *thenComparingDouble(function)*
- *thenComparingInt(function)*
- *thenComparingLong(function)*

### Generics

*Generics are use where we don't want to be type specific and are creating functionality that do not need to have 
a connection to the types they work with. Collections make a lot of use of generics.*

**Naming convention**:
- E for an element
- K for a map key
- V for a map value
- N for a number
- T for a generic data type
- S, U, V, ... for multiple generic types

**Type Erasure**:  
*Type erasure can be explained as the process of enforcing type constraints only at compile time and discarding 
the element type information at runtime.*

For example:

    class Crate<T> {
      private T content;
  
      public void loadCrate(T content){
          this.content = content;
      }
  
      public T unloadCrate(){
          return content;
      }
    }

Will be compiled to:

    class Crate {
      private Object content;
  
      public void loadCrate(Object content){
          this.content = content;
      }
  
      public Object unloadCrate(){
          return content;
      }
    }

#### Generic Interfaces

Interfaces can use generic types too:

    public interface Shippable<T> {
      void ship(T t);
    }

*When implemented to a class we can choose to specify a type or a generic type.
We can also just use Object instead of generics.*

#### Generic Methods

We can also use them in methods:

    public static <T> Crate<T> ship(T t){
        return new Crate<>();
    }

*We declare the formal type parameter before the return type.*

We can call this method normally, or define the type:

    Crate.ship("package")
    Crate.<String>ship("package")

#### What we can't do with generics

- Call a constructor (new T)
- Create an array of a generic type
- Call instanceof
- Use a primitive type as a generic type
- Create a static variable as a generic type

#### Bounding Generic Types

Wildcards:
- Unbounded wildcard
  - ?
  - Any type
- Upper-bounded wildcard
  - ? extends type
  - This type or any subtype
- Lower-bounded wildcard
  - ? super type
  - This type or any supertype

## Chapter 4: Functional Programming

**Functional Interfaces**:
- Supplier
```
public interface Supplier<T> {
  T get();
}
```
- Consumer
```
public interface Consumer<T> {
  void accept(T t);
}
```
- BiConsumer
```
public interface Biconsumer<T, U> {
  void accept(T t, U u);
}
```
- Predicate
```
public interface Predicate<T> {
  test(T t);
}
```
- BiPredicate
```
public interface BiPredicate<T, U> {
  test(T t, U u);
}
```
- Function
```
public interface Function<T, R> {
  R apply(T t);
}
```
- BiFunction
```
public interface BiFUnction<T, U, R> {
  R apply(T t, U u);
}
```
- UnaryOperator
```
public interface UnaryOperator<T> extends Function<T, T> {
  T apply(T t);
}
```
- BinaryOperator
```
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
  T apply(T t1, T t2);
}
```

**Convenience Methods**:
- Consumer
  - *andThen()*
- Function
  - *andThen()*
  - *compose()*
- Predicate
  - *and()*
  - *negate()*
  - *or()*

### Optional

The purpose of an optional is to provide a type-level solution for representing optional values instead of null references.

**Advantages over null**:
- Statement by API there might not be a value
- Functional programming
- Chaining optional calls

**Factory Methods**:
- *Optional.empty()*
- *Optional.of()*
- *Optional.ofNullable()*

**Methods**:
- *isPresent()*
- *get()*
- *ifPresent(Consumer c)*
- *orElse(T other)*
- *orElseGet(Supplier s)*
- *orElseThrow()*
- *orElseThrow(Supplier s)*

### Streams

Streams are like an assembly line, where Java is the foreman putting operators to work.
Every previous operation has to complete before the next can start.

Pipeline flow:
- Source
- Intermediate operations
- Terminal operation

#### Stream Sources

**Factory Methods**:
- Finite
  - *Stream.empty()*
  - *Stream.of()*
- Infinite
  - *Stream.generate()*
  - *Stream.iterate()*

**Collection API**:
- *stream()*
- *parallelStream()*

#### Terminal Operations

- *count()*
- *min()*
- *max()*
- *findAny()*
- *findFirst()*
- *allMatch()*
- *anyMatch()*
- *noneMatch()*
- *forEach()*
- *reduce()*
- *collect()*

#### Intermediate Operations

- *filter()*
- *distinct()*
- *limit()*
- *skip()*
- *map()*
- *flatMap()*
- *sorted()*
- *peek()*

### Primitive Streams

**Types**:
- IntStream
- LongStream
- DoubleStream

**Factory Methods**:
- Finite
  - *Stream.empty()*
  - *Stream.of()*
- Infinite
  - *Stream.generate()*
  - *Stream.iterate()*
  
**Primitive Stream Methods**:
- *average()*
>OptionalDouble average()
- *boxed()*
>Stream<T> boxed()
- *max()*
>OptionalInt max()
- *min()*
>OptionalLong min()
- *range(long a, long b)*
>IntStream range()
- *rangeClosed()*
>IntStream rangeClosed(int a, int b)
- *sum()*
> int sum()
- *summaryStatistics()*
> IntSummaryStatistics summaryStatistics()

#### Optionals with Primitive Streams

**Types**:
- OptionalInt
- OptionalDouble
- OptionalLong


#### Summary Statistics

We can only use one terminal operation on a stream once. If we want to do more calculations like getting an average, min and max and more,
we can use the summary statistics methods with our primitive streams.

- IntSummaryStatistics
- LongSummaryStatistics
- DoubleSummaryStatistics

Method:
- *summaryStatistics()*

#### Functional Interfaces for Primitives

Boolean~:
- BooleanSupplier

Int- Long- and Double~:
- IntSupplier
- IntConsumer
- IntPredicate
- IntFunction<R>
- IntUnaryOperator
- IntBinaryOperator


- ToIntFunction
- ToIntBiFunction
- IntToLongFunction
- IntToDoubleFunction
- ObjIntConsumer

*All of these also have their Double and Long variations.*

### Advanced Concepts

**Streams and underlying data**:  
Streams only are created when they are called. If a collection gets updated after the stream was described,
but before it is called, these changes will affect the result when the stream is called?

**Chaining optionals**:  
We can use flatMap() to remove an unnecessary layer and transform one optional type to another.

**Handling checked exceptions in a lambda**:  
- Catch and turn into unchecked exception (ugly)
- Create a wrapper method with a try/catch and use the wrapper in the lambda

#### Grouping/Partitioning Collectors

- averagingInt(ToIntFunction f)
- counting()
- groupingBy(Function f, Supplier s, Collector dc)
- joining(CharSequence cs)
- maxBy(Comparator c)
- minBy(Comparator c)
- mapping(Function f, Collector dc)
- partitioning(Predicate p, Collector dc)
- summarizingInt(ToIntFunction f)
- summingInt(ToIntFunction f)
- toList()
- toSet()
- toCollection(Supplier s)
- toMap(Function k, Function v, BinaryOperator m, Supplier s)

## Chapter 5: Exceptions, Assertions and Localizations

We handle exceptions with try-statements.

Try:
- try
- catch
- finally

*Needs either a catch or finally block.*

Try-with resources:
- try
- catch
- finally + implicit 

*Doesn't need catch or finally block, because resources are closed in an implicit finally block.*

**Unchecked Exceptions**:
- ArithmeticException
- ArrayIndexOutOfBoundsException
- ArrayStoreException
- ClassCastException
- IllegalArgumentException
  - NumberFormatException
- IllegalStateException
- MissingResourceException
- NullpointerException
- UnsuportedOperationException

**Checked Exception**:
- IOException
  - FileNotFoundException
  - NotSerializableException
- ParseException
- SQLException

*We can't list an exception in a multi-catch block that inherits from one of the others.
We can list them in consecutive catch blocks, but only with the most specific one first.*

**Custom exceptions**:
- Unchecked exception inherit from RuntimeException
- Checked Exceptions inherit from Exception

### Automating Resource Management

Closing resources is paramount for Java to be able to garbage collect the objects. 
Connections to resources left open will lead to resource leaks making our program vulnerable to attacks.

*Resources need to implement AutoCloseable. They will be closed before any catch- or finally block.*

We can reference resources that are effectively final (not reassigned). Even though it is a bad idea,
we can make method calls on them before the try block, but not after. The resource has than been closed.

### Suppressed Exceptions

The first exception thrown in the current try block is the primary exception. Any other exceptions 
thrown by the resources are considered suppressed exceptions.

If the exception isn't caught it will be thrown to the caller and eventually the main function would handle it.

We do not want to lose exceptions, so we want to make sure no exceptions can be thrown in the finally block.
Since resource management was added in Java 7 with backward compatibility and this behaviour existed before,
this is considered a bad practice.

### Assertions

Examples:

    assert boolean_expression;
    assert boolean_expression: error_message;

Short for:

    if(!boolean_expression) throw new AssertionError(error_message);

Assertions are disabled by default. We can run our code with assertions on:

- For one class:
>java -ea Rectangle
- For the whole program:
>java -ea:be.dog.d.steven... my.programs.Main
- For the whole program but one class:
>java -ea:be.dog.d.steven... -da:be.dog.d.steven.SomeClass my.program.Main

*We don't want assert-statements to alter the outcome of our code. They are only used when debugging,
and this would make our code run different in a test run compared to in production.*

### Dates and Times

New API:
- LocalDate
- LocalTime
- LocalDateTime
- ZonedDateTime

Creating dates or times uses **Factory Methods** because the 
- of()

Date/time symbols for formatting:
- y: year
- M: Month
- d: Day
- h: Hour
- m: Minute
- s: Second
- a: am/pm
- z: Time zone
- Z: Time zone offset

### Internationalization

Examples:
- es
- nl
- nl_BE
- en_GB
- en_UK

### Localizing Numbers

**NumberFormat Methods**:
- getInstance()
- getNumberInstance()
- getCurrencyInstance()
- getPercentInstance()
- getIntegerInstance()

*These take an optional locale as a parameter, without it the default will be used.*

**Custom NumberFormat**:
- \#: Omit if no digit exists
- 0: 0 if no digit exists

### Localizing Dates

**DateTimFormatter Methods**:
- ofLocalizedDate(dateStyle)
- ofLocalizedTime(timeStyle)
- ofLocalizedDateTime(dateStyle, timeStyle)
- ofLocalizedDateTime(dateTimeStyle)

*Locale.setDefault() allows a second Category parameter to further specify the setting of the Locale,
allowing finer-grained control over the Locale options.*

### Resource Bundles

Order to look for bundle:
1. Requested locale
2. Language locale
3. Default locale
4. Default language locale
5. Default bundle
6. MissingResourceException

Formatting messages:  
We can use parameters in our string resources from a bundle using {0}, {1}, ...

Example:
>MessageFormat.format(rb.getString("someFormattedStrinInBundle), "param1", "param2")

*This format() function takes in a vararg of strings. Too few varargs will make the placeholders visible.
Too many varargs will simply be ignored.*

### Properties

The properties class is like a HashMap<String, String>. It is comonly used in handling values that may not exist.

## Chapter 6: Modular Applications

**Directives**:
- exports <package>
- exports <package> to <module>
- requires <module>
- requires transitive <module>
- uses <interface>
- provides <interface> with <class>

**Types of Modules**:
- Named Modules
  - On module path
  - module-info.java file in root
  - One or more packages in root
- Automatic Modules
  - On module pat
  - Exports all packages
  - One or more packages in root
  - Java automatically determines the module name
    - Automatic-Module-Name in MANIFEST.MF (META-INF)
    - JAR-file name: holiday-calendar-1.0.0.jar -> holiday.calendar
      - Remove .jar
      - Remove version
      - Replace non-letters with .
      - No double .
      - No leading or trailing .
- Unnamed Modules
  - On class path
  - Doesn't work like a module
  - Does not export packages to named or automatic modules

Built in modules:
>java --list-modules

Java:
- java.base
- java.compiler
- java.datatransfer
- java.desktop
- java.instrument
- java.logging
- java.management
- java.management.rmi
- java.naming
- java.net.http
- java.prefs
- java.rmi
- java.scripting
- java.se
- java.security.jgss
- java.security.sasl
- java.smartcardio
- java.sql
- java.sql.rowset
- java.transaction.xa
- java.xml
- java.xml.crypto

Jdk:
- jdk.accessibility
- jdk.aot
- jdk.attach
- jdk.charsets
- jdk.compiler
- jdk.crypto.cryptoki
- jdk.crypto.ec
- jdk.crypto.mscapi
- jdk.dynalink
- jdk.editpad
- jdk.hotspot.agent
- jdk.httpserver
- jdk.incubator.foreign
- jdk.incubator.jpackage
- jdk.internal.ed
- jdk.internal.jvmstat
- jdk.internal.le
- jdk.internal.opt
- jdk.internal.vm.ci
- jdk.internal.vm.compiler
- jdk.internal.vm.compiler.management
- jdk.jartool
- jdk.javadoc
- jdk.jcmd
- jdk.jconsole
- jdk.jdeps
- jdk.jdi
- jdk.jdwp.agent
- jdk.jfr
- jdk.jlink
- jdk.jshell
- jdk.jsobject
- jdk.jstatd
- jdk.localedata
- jdk.management
- jdk.management.agent
- jdk.management.jfr
- jdk.naming.dns
- jdk.naming.rmi
- jdk.net
- jdk.nio.mapmode
- jdk.sctp
- jdk.security.auth
- jdk.security.jgss
- jdk.unsupported
- jdk.unsupported.desktop
- jdk.xml.dom
- jdk.zipfs

Example file:
    
    // Animatronics.java
    package zoo.dinos;

    import java.time.*;
    import java.util.*;
    import sun.misc.Unsafe;
    
    public class Animatronic {
    private List<String> names;
    private LocalDate visitDate;
    
        public Animatronic(List<String> names, LocalDate visitDate) {
            this.names = names;
            this.visitDate = visitDate;
        }
        
        public void unsafeMethod() {
            Unsafe unsafe = Unsafe.getUnsafe();
        }
    }

Compile:
>javac zoo/dinos/*.java

Create JAR:
>jar -cvf zoo.dino.jar .

List dependencies:
>jdeps zoo.dino.jar

Summarize dependencies:
>jdeps -s zoo.dino.jar

Get unsupported API from jdk:
>jdeps --jdk-internals zoo.dino.jar

**Migration strategies**:
- Bottom-up: 
  - From: unnamed on classpath
  - To: named on module path
- Top-down: 
  - Move all modules to the module path first
  - From: automatic on module path 
  - To: named on module path

**Cyclic dependencies**:
We fix cyclic dependencies with creating another module that holds the shared code.

### Creating a Service

Service with implementation:
>provides <path.to.Service> with <path.to.Implementation>

Part of service:
- Service provider interface
  - module-info.java:
    -exports
- Service locator
  - module-info.java:
    - exports
    - requires
    - uses

Not part of the service:
- Service provider
  - module-info.java:
    - requires
    - provides
- Consumer
  - module-info.java:
    - requires

*ServiceLoader\<S> has 2 methods: load(Class\<S> service) and stream().
The method stream() returns a stream of Provider\<S>, so we need to call get() 
to retrieve the wanted values out of the providers.*

## Chapter 7: Concurrency

### Thread

A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, 
which is typically a part of the operating system. The implementation of threads and processes differs between operating systems, 
but in most cases a thread is a component of a process. Multiple threads can exist within one process, 
executing concurrently and sharing resources such as memory, while different processes do not share these resources. 
In particular, the threads of a process share its executable code, the values of its dynamically allocated variables 
and non-thread-local global variables at any given time.

- System threads
- User defined threads

*This distinction means that all Java applications are multi-threaded. 
Daemon threads, like garbage collection, are threads that do not prevent the JVM from exiting when the program finishes.*

Scheduling:
- Context switches: Storing the state of a thread to later restore the thread and continue the process
- Thread priorities: A numeric value (in Java) associated with the thread indicating its priority

### Runnable

*Runnable is an interface used to define the work a thread will execute.*

    @FunctionalInterface
    public interface Runnable() {
      void run();
    }

The runnable interface:
- Does not take any parameters
- Does not return a value
- Can be used as lambda
- Can be implemented to a class

Creating a thread using the Thread class:
- Define the thread
  - Runnable object or lambda
  - Class that extends Thread
    - To create own priority-based thread
- Start the thread

*Java does not guarantee any order of execution.*

**Asynchronous**:  
Without waiting for the result of other threads

Methods:
- start(): starts a new thread
- run(): runs code but does not start a new thread
- shutdown()
- isShutdown()
- isTerminated()

### Concurrency API

The **Executors** class provides factory methods:
- newSingleThreadExecutor()
- newSingleThreadScheduledExecutor()
- newCashedThreadPool()
- newFixedThreadPool()
- newScheduledThreadPool()

**ExecutorService Methods**:
- *execute()*
  

    void execute(Runnable command)
- *submit()*
    
  
    Future<?> submit(Runnable task)  

    <T> Future<T> submit(Callable<T> task)
- *invokeAll()*


    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InteruptedException
- *invokeAny()*


    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InteruptedException, ExecutionException
- awaitTermination
  

    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
- isTerminated


    boolean awaitTermination()
*Unlike execute() and submit(), invokeAll() and invokeAny() execute synchronously. This means they are executed in order and can execute a List of tasks.*

### Future

Returned instance by various API, with useful methods to determine the state of a task.

**Future Methods**:
- *isDone()*
>boolean isDone()
- isCancelled()
>boolean isCancelled()
- cancel()
>boolean cancel(boolean mayInteruptIfRunning)
- get()
>V get()  
>V get(long timeout, TimeUnit unit)

### Callable

*Allows for more details to be retrieved than Runnable.*

    @FunctionalInterface
    public interface Callable<V>{
      V call() throws Exception;
    }

### Scheduling Tasks

**ScheduledExecutorService Methods**:
- *schedule()*


    schedule(Callable<V> callable, long delay, TimeUnit unit)

    schedule(Runnable command, long delay, TimeUnit unit)
- *scheduleAtFixedRate()*
  

    scheduleAtFixedRate(Runnable command, long initialDelay, long delay, TimeUnit unit)
- *scheduleWithFixedDelay()*


    scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)

### Thread Pool

*A pool of threads allowing tasks to be executed concurrently.*

Example of a fixed size thread pool:

    Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())

**Thread safety**:
Because some operations aren't thread safe there are multiple ways to support thread safety.

### Atomic Classes

- AtomicBoolean
- AtomicInteger
- AtomicLong

**Atomic Methods**:
- *get()*
- *set()*
- *getAndSet()*
- *incrementAndGet()*
- *getAndIncrement()*
- *decrementAndGet()*
- *getAndDecrement()*

### Synchronized Blocks

We can synchronize execution in a synchronized block. We can synchronize on any object, making this object final
ensures it is not reassigned after threads start using it.

Examples:

    synchronized(this) { ... }

    private final Object anyObject = new Object();
    synchronized(anyObject) { ... }

We can also use the synchronized keyword on methods:

    private synchronized void someMethod() { ... }

***Cost**:
We should avoid synchronization whenever we can, because it comes at a high performance cost.*

### Lock Framework

The lock framework offers more functionality than a synchronized block:
- Request lock without blocking
- Request a lock whiloe blocking for specified amount of time
- Create locks with fairness property, where the lock is granted to threads in the order they were requested

*We always need to release locks, and we shouldn't release locks that don't exist. In other words, 
the number of releases has to be equal to the number of locks granted.*

- ReentrantLock()
- ReentrantReadWriteLock()
- ...

Example:

    Lock lock = new ReentrantLock();
    try {
      lock.lock();
      // Protected code
    } finally {
      lock.unlock();
    }

**Methods**:
- *lock()*
>void lock()
- *unlock()*
>void unlock()
- *tryLock()*
>boolean tryLock()  
>boolean tryLock(long timeout, TimeUnit unit)

### Cyclic Barrier

Cyclic barriers allow us to better manage multithreaded tasks, by making all threads stop and wait at logical barriers.

    CyclicBarrier b1 = new CyclicBarrier(3);
    CyclicBarrier b2 = new CyclicVarrier(3, () -> System.out.println("some task to perfrom when all threads at barrier"));
    ...
    b1.await(); b2.await();

*These will make all threads wait for the (in this case) three threads to complete.
We should have a thread pool at least the size of the barrier limit to prevent the code to hang.*

### Concurrent Collections

Collections that provide thread safe reading and writing access.

- ConcurrentHashMap<>()
- ConcurrentLinkedQueue<>()

- ConcurrentSkipListSet<>()
  - Like TreeSet<>()
- ConcurrentSkipListMap<>()
  - Like TreeMap<>()
  
- CopyOnWriteArrayList<>()
- CopyOnWriteArraySet<>()

- LinkedBlockingQueue<>()

#### BlockingQueue

**Additional Methods**:
- offer(E element, long timeout, TimeUnit unit)
- poll(long timeout, TimeUnit unit)

### Collection API methods

- *synchronizedCollection(Collection<T> c)*
- *synchronizedList(List<T> list)*
- *synchronizedMap(Map<K,V> m)*
- *synchronizedNavigableMap(NavigableMap<K,V> m)*
- *synchronizedNavigableSet(NavigableSet<T> s)*
- *synchronizedSet(Set<T> s)*
- *synchronizedSortedMap(SortedMap<K,V> m)*
- *synchronizedSortedSet(SortedSet<T> s)*

*The collections that are returned are thread safe. However, the
maps can't be used to iterate over and modify themselves like the ConcurrentHshMap!*

### Liveness

Issues:
- Deadlock: Two or more threads are blocked forever
- Starvation: A thread is perpetually denied access to a shared resource or lock
- Livelock: Two threads trying to resolve a deadlock, restarting part of the process indefinitely

### Race Conditions

A race condition occurs when two or more threads can access shared data, and they try to change it at the same time.
Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which
the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on
the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.

### Parallel Streams

The stream API has built-in concurrency features.

On a stream:
- *parallel()*: Intermediate operation on an existing stream.
  Calling a terminal operation on it will also make the original unavailable.
- *isParallel()*: Checks if a stream is parallel.
  Some operations like flatmap() create a new stream that is not parallel by default.

On a collection:
- *parallelStream()*: Returns a parallel stream from a collection.

**Parallel Decomposition**:  
The process of taking a task and breaking it up into smaller peaces.

Most operations will behave different when it comes to order for parallel streams.

Order operations will have the same result for parallel as for serial streams:
- skip()
- limit()
- findFirst()
- ...

*These ordered operation will take more time for a parallel stream to complete. Sometimes making the
stream unordered can improve performance.*

**Requirements for a parallel reduction with collect()**:  
- The stream is parallel
- The parameter of the collect() operation has the Characteristics.CONCURRENT characteristic
- Either the stream is unordered or the collector has the characteristic Characteristics.UNORDERED

**Collector method**:
>characterisctics()

